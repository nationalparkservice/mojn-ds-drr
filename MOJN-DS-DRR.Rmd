---
params:

  reportNumber: ""                           # Optional. Only include this if publishing in the semi-official Data Release Report Series. Contact Joe if you are.
  reportRefID: 
  packageAbstract: >-
    This report summarizes data quality evaluations of discrete data collected for the Mojave Desert Network Inventory and Monitoring Program (MOJN I&M) Desert Springs (DS) protocol from 2016 to 2022. This protocol is designed to monitor hydrological and ecological condition at 250 springs in Death Valley National Park (DEVA), Joshua Tree National Park (JOTR), Lake Mead National Recreation Area (LAKE), Mojave National Preserve (MOJA), and Grand Canyon-Parashant National Monument (PARA). Data collected include water quantity and water quality measurements as well as site condition information about dominant vegetation, invasive plants, disturbance, and wildlife evidence.
  dataPackage1RefID: 
  dataPackage1Title: "MOJN I&M Desert Springs Data Package 2016-2022"               # Should match title in data store.
  dataPackage1Description: "MOJN I&M DS 2016-2022"  
  dataPackage2RefID: 0                              # Data Store reference ID for data set associated with this report. You must have at least one.
  dataPackage2Title: "Dataset 2 FULL TITLE"               # Should match title in data store.
  dataPackage2Description: "SHORT TITLE FOR DATASET 1"  
  dataSource: "database"  # Either "local" or "database". If "local", csv data must be in data/raw folder. If database, must be able to connect to the MOJN DS SQL Server db.
  isAccessible: "no" # Either "yes" for a version that is screen-readable or "no" for a version with interactive table and plot formatting.
  wateryearStart: "2016"
  wateryearEnd: "2022"
  
title: |
    | Mojave Desert Network Desert Springs
    | Data Package 2016-2022          
subtitle: |
  | Data Release Report `r params$reportNumber` 
author:
  - name: "Jennifer Bailard"
    affiliation: |
      | Mojave Desert Network
      | Inventory and Monitoring Program 
      | 101 Katzenbach Drive
      | Boulder City, Nevada
date: "`r format(Sys.time(), '%d %B, %Y')`"
abstract: "`r params$packageAbstract`"
editor_options:
  chunk_output_type: inline
csl: https://raw.githubusercontent.com/citation-style-language/styles/master/apa.csl
link-citations: yes
output:
  html_document:
    df_print: kable
    fig_caption: true
    dev: svg
    highlight: haddock
    smart: no
    theme: journal
    css: !expr here::here('common', 'journalnps.min.css')
    toc: yes
    toc_float: true
    number_sections: true
    includes:
        before_body:
          - !expr here::here('common', 'header.html')
        after_body: 
          - !expr here::here('common', 'footer.html')
  word_document:
    df_print: kable
    fig_caption: yes
    fig_height: 5
    fig_width: 5
    highlight: haddock
    reference_docx: !expr here::here('common', 'DRR Word Template.docx')
---

```{r setup, include = FALSE}

# This setup code loads both reproducible reporting packages
# (delete those not needed) and packages for the actual project.
# Note that it also generates the start of a BibTex literature cited
# including the citations for R and all used packages

# reproducible reporting packages
RRpackages <- c('markdown',     # links to Sundown rendering library
                'rmarkdown',    # newer rendering via pandoc
                'pander',       # alternative renderer for markdown, plus better tables than just knitr
                'knitr',
                "dataMaid",     # for makeCodebooks
                "R.rsp",        # dynamic generation of scientific reports
                "kimisc",       #
                "papeR",        # stat tables
                "texreg",       # formatting regression results for LaTeX or html
                "rmdHelpers",   # misc from Mark Peterson thisFileName() thisFile_knit()
                'yaml',         # format data into markdown
                'rmdformats',   # templates including automatic ToC, also use_bookdown()
                'htmltools',    #
                "bibtex",
                "RefManageR",   # BibTeX reference manager
                "knitcitations",# For working with file paths
                "here"          # nice HTML widget tables
)

inst <- RRpackages %in% installed.packages()
if (length(RRpackages[!inst]) > 0) {
  install.packages(RRpackages[!inst], dep = TRUE, repos = "http://cran.rstudio.com/") # "https://cloud.r-project.org"
}
lapply(RRpackages, library, character.only = TRUE)

# Now repeat for packages used in the analyses
pkgList <- c("devtools",        # tends to be needed/useful
             "RODBC",           # for connection to a database. 
             "EML",             # for data package creation and validation
             "kableExtra",      # added features for table formatting. 
             "english",         # converts numbers into english. Good for all that English stuff.
             "remotes",         # for install_github()
             "tidyverse",       # useful
             "formatR",
             "magrittr",
             "leaflet",
             "plotly",
             "svglite",
             "scales",
             "reactable",
             "slickR",
             "gridExtra",
             "glue",
             "tidytext",
             "DT")

inst <- pkgList %in% installed.packages()
if (length(pkgList[!inst]) > 0) {
  install.packages(pkgList[!inst], dep = TRUE, 
                   repos = "http://cran.rstudio.com/") # "https://cloud.r-project.org"
}

lapply(pkgList, library, character.only = TRUE, quietly = TRUE)

options(download.file.method = "wininet")
if (! "EMLassemblyline" %in% installed.packages()) remotes::install_github("EDIorg/EMLassemblyline")
if (! "desertsprings" %in% installed.packages()) remotes::install_github("nationalparkservice/mojn-ds-rpackage")
require("EMLassemblyline")
require("desertsprings")

# create stub of citations for packages
pkgBibTex <- lapply(c("base", pkgList, RRpackages), citation)

# pkgBibTex <- do.call()

knitr::opts_chunk$set(
  root.dir = here::here(),
  echo = FALSE,
  comment = " ",
  dev = "svg",
  fig.path = here::here("figures"),
  tidy.opts = list(width.cutoff = 60),
  tidy = TRUE
)
# if ggplot, update theme to default to centered titles
if ("ggplot2" %in% .packages()) {
  theme_update(plot.title = element_text(hjust = 0.5))
}

knitr::opts_chunk$set(fig.width=8)

conn <- OpenDatabaseConnection()

# Convert start and end water years assigned in the params to a year range that can be applied to functions through the field.season parameter
wy <- as.numeric(params$wateryearStart)
end <- as.numeric(params$wateryearEnd)

years <- tibble::tibble(wy) %>%
  tibble::add_row(wy = end) %>%
  tidyr::complete(wy = tidyr::full_seq(wy, 1)) %>%
  unique() %>%
  dplyr::mutate(wy = as.character(wy))
  
years <- paste0(years$wy)

year.range <- years

# Function to adjust position of axis and legend labels in plotly objects
layout_ggplotly <- function(gg, x = -0.1, y = -0.05, x_legend=1.05, y_legend=0.95, mar=list(l=50, r=150)){
  # The 1 and 2 goes into the list that contains the options for the x and y axis labels respectively
  gg[['x']][['layout']][['annotations']][[1]][['y']] <- x
  gg[['x']][['layout']][['annotations']][[2]][['x']] <- y
  # gg[['x']][['layout']][['annotations']][[0]][['x']] <- x_legend # the legend title was the 11-th list element in my case!
  gg[['x']][['layout']][['legend']][['y']] <- y_legend
  gg[['x']][['layout']][['legend']][['x']] <- x_legend
  gg %>% layout(margin = mar)
}

#Determine the output format of the document
outputFormat   = opts_knit$get("rmarkdown.pandoc.to")

#Figure and Table Caption Numbering, for HTML do it manually
capTabNo = 1; capFigNo = 1;

#Function to add the Table Number
capTab = function(x){
  if(outputFormat == 'html'){
    x = paste0("<B>Table ", capTabNo, ". ", "</B>", x)
    capTabNo <<- capTabNo + 1
  }; x
}

#Function to add the Figure Number
capFig = function(x){
  if(outputFormat == 'html'){
    x = paste0("<B>Figure ", capFigNo, ". ", "</B>", x)
    capFigNo <<- capFigNo + 1
  }; x
}
```

``` {r setup.wait, include = FALSE, eval = FALSE}
# Write YAML parameters to file for consistent reuse across report and data packages
save(params,file=here::here("data", "temp", "reportParameters.RData"))

if (params$dataSource == "database") {
  conn <- tryCatch(OpenDatabaseConnection(),
                   error = {conn <- NA})
} else {
  conn <- NA
} 
raw_data_path <- here::here("data", "raw")


```{r GenerateMetadata, eval = FALSE}
source(here::here("dataPackages", "DataPackageTemplate", "generate-metadata.R"))
```

```{r LoadData, include = FALSE}
# Load datasets for use

if (file.exists(file=here::here("data", "temp", "projectMetadata.RData"))) {
  load(file=here::here("data", "temp", "projectMetadata.RData"))
} else{
  projectMetadata<-list()
}
```

<hr>
# Background & Introduction

The following information is summarized from the *Springs in the Mojave Desert Network—Surface water monitoring at desert springs: Protocol narrative version 1.0* (NPS/MOJN/NRR—2018/1718), available here: https://irma.nps.gov/DataStore/Reference/Profile/2254900. Refer to the protocol narrative for more detailed information.

## Significance

Springs are water sources that form where groundwater reaches the land surface. They can range in size from seasonal seeps that go dry in the summer to perennial streams that flow all year long and support large wetland environments (Figure 1). Compared to the surrounding desert, spring and wetland environments in the Mojave and Great Basin regions support a greater abundance and diversity of plant and animal life. Large mammals, like desert bighorn sheep, depend on standing water to survive the heat of summer. Many birds depend on riparian habitat during their migratory seasons, and bats frequent open pools when foraging for insects. Some springs support rare or endemic species, including fish, amphibians, and aquatic invertebrates. Reliable water sources are scarce, so springs are often vital to the distribution and connectivity of wildlife habitat across the landscape.

``` {r figure1, echo = FALSE, fig.align = "left", fig.cap = capFig("Examples of springs in the Mojave Desert."), height = 480, fig.alt = "Twelve photos of diverse springs across the network parks."}

dat <- tibble::tibble(filepath = glue::as_glue(c(here::here("figures", "MOJA_P_BLA0014.JPG"),
                                                 here::here("figures", "JOTR_P_QUE0109.JPG"),
                                                 here::here("figures", "LAKE_P_SAL0019.JPG"),
                                                 here::here("figures", "PARA_P_DEA0145.JPG"),
                                                 here::here("figures", "MOJA_P_SIL0180.JPG"),
                                                 here::here("figures", "DEVA_P_COR0991.JPG"),
                                                 here::here("figures", "LAKE_P_GRA0058.JPG"),
                                                 here::here("figures", "DEVA_P_CUR0123.JPG"),
                                                 here::here("figures", "PARA_P_RAT0212.JPG"),
                                                 here::here("figures", "DEVA_P_GNO0081.JPG"),
                                                 here::here("figures", "DEVA_P_COT0794.JPG"),
                                                 here::here("figures", "JOTR_P_COT0294.JPG"))))

alt_text <- c("Small, muddy puddle emerges from hillside, with cattle activity in the spring. There are some posts and other old remains of an exclosure fence around the source.",
              "Small pool is situated in sand and bedrock at the bottom of a bouldery canyon.",
              "Hot spring flows over a waterfall in a narrow canyon and is dammed by sandbags at the bottom to form a bathing pool.",
              "Shallow, broad pond is situated in a grassy depression with pine trees in the background.",
              "Shallow springbrook emerges from a qanat, with active pipe diversion and cattle activity in the spring.",
              "Small pool supporting goldenrods emerges from a very steep hillside with little other vegetation around.",
              "High discharge spring flows over a waterfall into a large, deep pool in a narrow canyon. The canyon is full of lush riparian vegetation, including cattails, monkeyflowers, grapevines, willows, and ferns.",
              "Small, shallow pool emerges in the middle of sparse desert shrubland and flows for a few meters downslope.",
              "Water seeps out of contacts between bedrock layers, with active pipe diversion of the seepage.",
              "Long, narrow springbrook winds through a salt flat devoid of vegetation.",
              "Shallow springbrook is covered by aquatic plants in the shade of large cottonwood trees and other woody vegetation.",
              "Dry spring is situated in a sandy wash below cluster of fan palms in a bouldery canyon.")

cap <- c("Black Bird Mine Spring, Mojave National Preserve",
         "Queen Mountain Spring, Joshua Tree National Park",
         "Salt Cedar Hot Spring, Lake Mead National Recreation Area",
         "Death Valley Pond, Parashant National Monument",
         "Silver Lead Qanat, Mojave National Preserve",
         "Corkscrew Spring, Death Valley National Park",
         "Grapevine Spring, Lake Mead National Recreation Area",
         "Currie Wells, Death Valley National Park",
         "Rattlesnake Spring, Parashant National Monument",
         "Gnome Spring, Death Valley National Park",
         "Cottonwood Spring, Death Valley National Park",
         "Cottonwood Palm Spring, Joshua Tree National Park")

imgs_alt <- mapply(function(x, txt){
  htmltools::tags$img(src = x, title = txt)
}, x = dat$filepath, txt = alt_text, SIMPLIFY = FALSE)

cP1 <- htmlwidgets::JS("function(slick,index) {
                            return '<a>'+(index+1)+'</a>';
                       }")

opts_dot_number <- slickR::settings(
    focusOnSelect = TRUE,
    dots = TRUE,
    customPaging = cP1
    )

slick_dots <- slickR::slickR(
  obj = imgs_alt,
  height = 400,
  width = "60%"
  )

slick_cap_synch <- slickR(obj = cap, slideType = "p") + settings(arrows = FALSE)

slick_dots %synch% slick_cap_synch + opts_dot_number 

```

## Threats and Stressors

Springs are vulnerable to several stressors, including climate change and groundwater withdrawal. In the southwestern United States, increasing air temperatures and declining snowpacks have intensified drought and reduced aquifer recharge (USGCRP 2018). Springs fed by small, local aquifers are particularly vulnerable to drought. They may experience lower discharge or even go dry entirely. Springs fed by larger, regional aquifers are more resilient to recent climate change but may be vulnerable to groundwater withdrawal happening outside of their park. For large aquifers with slow recharge, it may take centuries for water levels to recover after pumping is discontinued (Bredehoeft and Durbin 2009). At all springs, higher air temperatures can lead to water loss through increases in evapotranspiration as well as changes in plant communities and wildlife use patterns.

Other stressors include surface water diversions, livestock disturbance, recreation, and invasive species. Active and historical diversions, such as pipes and troughs, are widespread at springs within the network and may alter or eliminate downstream riparian habitat. Grazing and trampling by livestock, such as cattle, feral donkeys (burro), and feral horses, can also negatively affect riparian vegetation and habitat. Threats from improper recreation include social trails, fire pits, bank degradation, and failure to dispose of garbage and human waste. Invasive trees like salt cedar and palms often outcompete native plants for limited water and nutrients, and invasive grasses are shifting fire regimes across the landscape. Invasive animals, including amphibians, fish, arthropods, and molluscs, can put pressure on native species through predation, hybridization, or competition for resources.

## Sample Design

The Mojave Desert Network Inventory and Monitoring Program (MOJN I&M) monitors 248 springs across Death Valley National Park (DEVA), Joshua Tree National Park (JOTR), Lake Mead National Recreation Area (LAKE), Mojave National Preserve (MOJA), and Grand Canyon-Parashant National Monument (PARA) as part of the Desert Springs protocol (Figure 2). Springs were selected at each park using a Generalized Random Tessellation Stratified (GRTS) spatially-balanced random sample.

A subset of 60 springs are monitored annually and are equipped with data-logging sensors to provide continuous records of surface water presence. There are 20 annual springs in DEVA and 10 annual springs in the other four parks. The remaining 188 springs are monitored on a 3-year rotation. There are 60 3-year springs in DEVA, 35 in MOJA, 35 in PARA, 33 in LAKE, and 25 in JOTR. Approximately 120 springs are monitored each field season.

``` {r figure2, echo = FALSE, fig.align = "left", fig.cap = capFig("Map of desert springs monitoring locations. Blue circles indicate springs monitored every year. Red circles indicate springs monitored every three years."), fig.alt = "Map of 248 springs monitored by MOJN I&M across the five network parks."}
locationmap <- LocationMap(conn)

locationmap
```

## Monitoring Questions

Given the ecological importance of springs and the threats that they face, the Desert Springs protocol was developed to address the following monitoring questions:

- Is water availability at springs changing over time?
- Is water quality at springs changing over time?

The protocol investigates these monitoring questions by collecting long-term data for the following quantitative measurable objectives:

- Status and trends of water availability (flow condition, discharge, and surface water length).
- Status and trends of water quality (temperature, pH, specific conductance, and dissolved oxygen).

In addition to these measurable objectives, the protocol also collects qualitative site condition information, including:

- Dominant vegetation
- Invasive plants
- Disturbance
- Wildlife evidence
- Repeat Photographs

Because MOJN I&M field crews are often the only NPS field crews visiting many of these springs regularly, this site condition information can provide park managers with useful information about springs that would not be collected otherwise.

# Methods

## Data Collection

Field methods used are described in *Springs in the Mojave Desert Network—Surface water monitoring at desert springs: Standard operating procedures version 1.0*, available here: https://irma.nps.gov/DataStore/Reference/Profile/2256063. Specific methods include SOP 4: Spring Acceptance and Classification, SOP 5: Water Availability: Flow Condition, SOP 6: Water Availability: Data-Logging Sensors, SOP 7: Water Quality, SOP 8: Site Condition: Spring Vegetation, SOP 9: Site Condition: Invasive Plants, SOP 10: Site Condition: Disturbance, and SOP 11: Site Condition: Repeat Photographs. Table 1 summarizes all measurements that are collected for the protocol.

``` {r table1, fig.cap = capTab("Monitoring data collected for the Desert Springs protocol.")}

type <- c("Quantitative", "Quantitative", "Quantitative", "Qualitative", "Qualitative", "Qualitative", "Qualitative", "Qualitative")

msr <- c("Water Availability (Discrete)", "Water Availability (Continuous)", "Water Quality", "Dominant Vegetation", "Invasive Plants", "Wildlife Evidence", "Disturbance", "Repeat Photographs")

dscr <- c("Flow condition (presence or absence of surface water), discharge (flow rate of surface water), surface water dimensions (length and width of surface water)", "Record of wet / dry cycle (data-logging sensors)", "Core parameters (temperature, pH, specific conductance, and dissolved oxygen)", "Ranking of vegetation life forms within spring area", "List of invasive plants found within spring area", "List and description of wildlife evidence within spring area", "Index of natural and anthropogenic disturbances within spring area", "Visual documentation of spring source, upstream, and downstream")

tbl <- tibble::tibble(type, msr, dscr) %>%
  dplyr::rename(MeasurementType = type,
                Measurement = msr,
                Description = dscr)

if (params$isAccessible == "yes") {
  knitr::kable(tbl) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  tbl %>%
    reactable(compact = TRUE,
              striped = TRUE,
              columns = list(
                MeasurementType = colDef(width = 160),
                Description = colDef(minWidth = 180)))
}
```

## Data Processing

Data were evaluated using a collection of QC checks that are part of the MOJN I&M Streams and Lakes R package. These evaluations are summarized in Section 4 of this document. Where unresolvable data quality issues existed, they have been described by a flag note in the data record, and a flag has been assigned to indicate the level of concern. These flags include Information (not expected to impact the validity of this data), Warning (care should be taken when including this record in analyses), and Critical (serious concerns about the quality of this record and it should not be used in analyses).

## Code Availability

All of the code used in the preparation of this data package is available in the MOJN I&M Desert Springs R Package [INSERT LINK].

# Data Records
The published product is one data package containing multiple CSV data files:

* **`r params$dataPackage1Title`.** Comma-separated text files containing data from the MOJN I&M Desert Springs protocol. These data were compiled by the MOJN I&M and were last updated on <INSERT DATE>. Available at `r paste0("https://irma.nps.gov/DataStore/Reference/Profile/", params$dataPackage1RefID)`. 

[INSERT NUMBER] CSV data files contain raw values suitable for use with the MOJN I&M Desert Springs R package. [INSERT NUMBER] additional CSV data files contain calculated values generated using this R package. These files are clearly labeled as "calculated" (Table 2).

A data dictionary for all of the tables and fields in the published CSV files is provided in XML format with this data package. 

```{r table2, echo = FALSE, fig.cap = capTab("File names and descriptions of published CSVs accompanying this data release report.")}
FileName <- c("DischargeEstimated", "DischargeFlowCondition", "DischargeVolumetric", "Disturbance", "DisturbanceFlowModification", "Invasives", "Riparian", "SensorRetrievalAttempts", "SensorsCurrentlyDeployed", "SensorsNeverDeployed", "Site", "Visit", "VisitActivity", "WaterQualityDO", "WaterQualitypH", "WaterQualitySpCond", "WaterQualityTemperature", "Wildlife")
Description <- c("Visually estimated discharge categories at springs", "Springbrook lengths, widths, and flow condition categories", "Volumetrically collected discharge measurements at springs", "Natural and anthropogenic disturbance presence, cover classes, and descriptions at springs", "Presence and type of surface flow modification at springs", "Invasive vegetation species observed at springs", "Vegetation life form category presence, rank, and dominant species", "PLACEHOLDER", "PLACEHOLDER", "PLACEHOLDER", "Description and location of site codes used in this dataset", "PLACEHOLDER", "Summary of types of data collected during site visit", "Dissolved oxygen measured in springs", "pH measured in springs", "Specific conductance measured in springs", "Temperature measured in springs", "Wildlife use evidence types and descriptions")
Table <- data.frame(FileName, Description)

reactable(Table,
          columns = list(FileName = colDef(name = "Filename")),
          pagination = FALSE,
          compact = TRUE, striped = TRUE)

```

# Data Quality Evaluation

The data within the data records listed above have been reviewed by staff in the NPS Inventory and Monitoring Division to ensure accuracy, completeness, and consistency with documented data quality standards, as well as for usability and reproducibility. For additional information on data quality standards for this protocol, refer to *Data Quality Standards for Springs in the Mojave Desert Network–Surface Water Monitoring at Desert Springs* (NPS/MOJN/NRR—2018/1819), available here: https://irma.nps.gov/DataStore/Reference/Profile/2257548.

## Advice and Caveats
 
- During the first field season in WY2016, LAKE springs were monitored in March and April. In all subsequent field seasons, LAKE springs were monitored in November and December.
- CAMO was established in February 2016. It was inventoried in November 2016, and two possible springs were identified. These two springs are monitored opportunistically every 3-years at the same time as the MOJA 3-year springs.
- Due to the 35-day lapse in federal appropriations from late December 2018 to late January 2019, one annual spring in DEVA and both springs in CAMO were not monitored during WY2019.
- Due to COVID-19 pandemic travel restrictions beginning in March 2020, monitoring of annual and 3-year springs was not completed in PARA during WY2020.
- Due to COVID-19 pandemic travel restrictions from December 2020 to February 2021, monitoring of 3-year springs was not completed in DEVA during WY2021. Some annual springs were monitored later than usual during the field season, when field work was allowed to resume.
- In WY2016, water quality instruments were not maintained to protocol standards. In particular, dissolved oxygen and pH measurements from the first field season may not be high quality data.
- In WY2018, calibration and measurement of dissolved oxygen percent began using the local dissolved oxygen percent convention. Dissolved oxygen percent may not be comparable between years before and after this change.
- In WY2019, ungulate observations were separated from mammal observations in wildlife evidence.
- In WY2021, measurement of springbrook length was separated into continuous and discontinuous measurements. Previously, only continuous springbrook length was measured.

`r if(params$isAccessible == "yes") {"## General"} else {"## General {.tabset}"}`

### Not sampled

This table lists springs that were not sampled during a field season or visit when they were intended to be monitored. No spring found indicates that there was no evidence of recent discharge, even periodic. Evidence could include riparian or denser wash vegetation or channelization. No spring found usually leads to a spring being rejected and removed from the sample frame. Inaccessible indicates that there were temporary or permanent barriers to physically reaching a spring. Barriers could include road washouts, unsafe terrain, or private property. Some springs were deemed inaccessible due to unsafe terrain in the office, while other springs were deemed inaccessible upon observation of unsafe terrain in the field. Inaccessible springs are skipped in the GRTS draw order, but they are not rejected or removed from the sample frame.

``` {r notsampled, fig.cap = capTab("Springs that were not samped during a field season.")}
notsampled <- qcNotSampled(conn = conn, data.source = "database")

notsampled %<>%
  select(-c(VisitType)) %>%
  arrange(SiteCode)

if (params$isAccessible == "yes") {
  knitr::kable(notsampled) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  reactable(dplyr::select(notsampled, -Notes),
            defaultColDef = colDef(minWidth = 50),
            searchable = TRUE,
            details = colDef(
              name = "Notes",
              details = function(index) {
                note <- notsampled$Notes[index]
                if (!is.na(note)) {
                  return(note)
                }
              }
            ),
            resizable = TRUE,
            compact = TRUE,
            striped = TRUE)
}
```

### Completeness 

This table provides the number and percentage of springs monitored at each park for each field season. Large disruptions to the field season occurred in WY2019 with the 35-day lapse in federal appropriations and in WY2020 and WY2021 with travel restrictions due to the COVID-19 pandemic.

``` {r completeness, message = FALSE, warning = FALSE, fig.cap = capTab("Number and percent of springs monitored at each park for each field season.")}
completeness <- qcCompleteness(conn = conn, data.source = "database")

completeness %<>%
  dplyr::mutate(Percent = round(Percent, 1)) %>%
  dplyr::filter(MonitoringStatus == "Sampled")

if (params$isAccessible == "yes") {
  knitr::kable(completeness) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  completeness %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Completeness plot

This stacked bar plot shows the percentage of springs monitored at each park for each field season. Large disruptions to the field season occurred in WY2019 with the 35-day lapse in federal appropriations and in WY2020 and WY2021 with travel restrictions due to the COVID-19 pandemic.

``` {r completeness.plot, message = FALSE, warning = FALSE, fig.cap = capFig("Stacked bar plot of annual and 3-yr spring sampled and not sampled at each park for each field season."), fig.alt = ""}
completeness.plot <- qcCompletenessPlot(conn = conn, data.source = "database")

if (params$isAccessible == "yes") {
  completeness.plot
} else {
  ggplotly(completeness.plot) %>%
    layout(
      legend = list(
        orientation = "h",
        y = -0.2,
        title = list(text = "Sample Status")
      )
    )  
}
```

### Visit dates

This table provides the date (month and day) that each spring was visited during each field season. Springs should be visited at approximately the same time of year during each field season, ideally within a few weeks, in order to minimize seasonal effects on the data.

``` {r visitdate, warning = FALSE, fig.cap = capTab("Date (month and day) that each spring was visited during each field season.")}
visitdate <- qcVisitDate(conn = conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(visitdate) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  visitdate %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Visit dates timeline

These timelines show the date (month and day) that each spring was visited during each field season. They also show the median visit date across all field seasons at each spring. Springs should be visited at approximately the same time of year during each field season, ideally within a few weeks, in order to minimize seasonal effects on the data.

``` {r visitdate.timeline.1, warning = FALSE, out.height = 1600, fig.cap = capFig("Timeline of annual and 3-yr spring visits in DEVA."), fig.alt = ""}
visitdate.plots <- qcVisitDateTimelines(conn = conn, park = "DEVA", data.source = "database")

if (params$isAccessible == "yes") {
  visitdate.plots
} else {
  p <- ggplotly(visitdate.plots, tooltip = c("text"))
  
  for (i in 1:length(p$x$data)){
     if (!is.null(p$x$data[[i]]$name)){
         p$x$data[[i]]$name =  gsub("\\(","",str_split(p$x$data[[i]]$name,",")[[1]][1])
     }
   }
  p
}
```

``` {r visitdate.timeline.2, warning = FALSE, out.height = 800, fig.cap = capFig("Timeline of annual and 3-yr spring visits in JOTR."), fig.alt = ""}
visitdate.plots <- qcVisitDateTimelines(conn = conn, park = "JOTR", data.source = "database")

if (params$isAccessible == "yes") {
  visitdate.plots
} else {
  p <- ggplotly(visitdate.plots, tooltip = c("text"))
  
  for (i in 1:length(p$x$data)){
     if (!is.null(p$x$data[[i]]$name)){
         p$x$data[[i]]$name =  gsub("\\(","",str_split(p$x$data[[i]]$name,",")[[1]][1])
     }
   }
  p
}
```

``` {r visitdate.timeline.3, warning = FALSE, out.height = 800, fig.cap = capFig("Timeline of annual and 3-yr spring visits in LAKE."), fig.alt = ""}
visitdate.plots <- qcVisitDateTimelines(conn = conn, park = "LAKE", data.source = "database")

if (params$isAccessible == "yes") {
  visitdate.plots
} else {
  p <- ggplotly(visitdate.plots, tooltip = c("text"))
  
  for (i in 1:length(p$x$data)){
     if (!is.null(p$x$data[[i]]$name)){
         p$x$data[[i]]$name =  gsub("\\(","",str_split(p$x$data[[i]]$name,",")[[1]][1])
     }
   }
  p
}
```

``` {r visitdate.timeline.4, warning = FALSE, out.height = 800, fig.cap = capFig("Timeline of annual and 3-yr spring visits in MOJA."), fig.alt = ""}
visitdate.plots <- qcVisitDateTimelines(conn = conn, park = "MOJA", data.source = "database")

if (params$isAccessible == "yes") {
  visitdate.plots
} else {
  p <- ggplotly(visitdate.plots, tooltip = c("text"))
  
  for (i in 1:length(p$x$data)){
     if (!is.null(p$x$data[[i]]$name)){
         p$x$data[[i]]$name =  gsub("\\(","",str_split(p$x$data[[i]]$name,",")[[1]][1])
     }
   }
  p
}
```

``` {r visitdate.timeline.5, warning = FALSE, out.height = 800, fig.cap = capFig("Timeline of annual and 3-yr spring visits in PARA."), fig.alt = ""}
visitdate.plots <- qcVisitDateTimelines(conn = conn, park = "PARA", data.source = "database")

if (params$isAccessible == "yes") {
  visitdate.plots
} else {
  p <- ggplotly(visitdate.plots, tooltip = c("text"))
  
  for (i in 1:length(p$x$data)){
     if (!is.null(p$x$data[[i]]$name)){
         p$x$data[[i]]$name =  gsub("\\(","",str_split(p$x$data[[i]]$name,",")[[1]][1])
     }
   }
  p
}
```

### Repeat visits

This table provides a list of springs that were visited multiple times during a field season. There should only be one primary visit per field season. Supplemental visits involve collecting specific data to supplement the data collected during the primary visit. Supplemental visits typically occur when a sensor is inadvertently forgotten during the primary visit and the spring is revisited later in the field season for sensor deployment. Replicate visits involve collecting a full set of data in addition to the data collected during the primary visit. Replicate visits may occur during training or when calibrating or comparing field crews.


``` {r repeats, fig.cap = capTab("Springs visited more than one time per field season.")}
repeats <- qcRepeatVisits(conn = conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(repeats) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  reactable(dplyr::select(repeats, -Notes),
            defaultColDef = colDef(minWidth = 50),
            searchable = TRUE,
            details = colDef(
              name = "Notes",
              details = function(index) {
                note <- repeats$Notes[index]
                if (!is.na(note)) {
                  return(note)
                }
              }
            ),
            resizable = TRUE,
            compact = TRUE,
            striped = TRUE)
}
```


### Spring type discrepancies

This table provides a list of springs that have been categorized differently (e.g., rheocrene vs hillslope) during different visits. Discrepancies typically occur when a spring is dry, and it is difficult to determine the spring type, or when a spring exhibits multiple spring types along its reach.

``` {r discrepancies, fig.cap = capTab("Springs that have been assigned different spring types during different visits.")}
discrepancies <- qcSpringTypeDiscrepancies(conn = conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(discrepancies) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  discrepancies %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Data processing levels

This table lists site visits that have any data labeled as "Raw" or "Provisional." These data need to be reviewed and moved to "Accepted" status before publication of the dataset.

``` {r dpl.check, echo = FALSE, message = FALSE, warning = FALSE, fig.cap = capTab("Records with data still labeled as Raw or Provisional.")}
dpl.check <- qcDPLCheck(conn, data.source = "database")

if (params$isAccessible == "yes") {
  dpl.check %>%
    rename_with(~ gsub(".DPL", "", .x)) %>%
    knitr::kable() %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  dpl.check %>%
    rename_with(~ gsub(".DPL", "", .x)) %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```
`r if(nrow(dpl.check) == 0){"All records have been accepted."}`
`r if(nrow(dpl.check) > 0){"The above records need to be reviewed and accepted before publication."}`

`r if(params$isAccessible == "yes") {"## Sensor information"} else {"## Sensor information {.tabset}"}`

### Sensor summary

This table summarizes sensor deployment, recovery, and successful download status for each park and field season. Percent retrieved is the percentage of sensors that were successfully recovered of those where a recovery attempt was made. Percent downloaded is the percentage of sensors that were successfully downloaded of those recovered. Beginning in 2019, a new sensor model was deployed that raised the percent downloaded success rate to 100%.

``` {r sensorsummary, fig.cap = capTab("Sensor deployment, recovery, and download summaries.")}
summary <- qcSensorSummary(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(summary) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  summary %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Sensor recovery heatmap

This heatmap shows which sites have consistent sensor recovery, sensor loss, or a combination of both. Gaps indicate that a sensor was not deployed during that field season.

``` {r sensorheatmap, out.height = 1000, fig.cap = capFig("Heatmap of sensor recovery at annual springs.")}
heatmap <- qcSensorHeatmap(conn, data.source = "database")

if (params$isAccessible == "yes") {
  heatmap
} else {
  ggplotly(heatmap, tooltip = "text")
}
```

### Sensors not deployed

This table lists annual springs where a sensor was not deployed. If there is a visit date associated with the field season, then the spring was visited, but a sensor was not deployed during the visit. If there is no visit date associated with the field season, then the spring was not visited during that field season.

``` {r nodeployment, fig.cap = capTab("Annual spring visits where a sensor was not deployed.")}
nodata <- qcSensorsNotDeployed(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(nodata) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  nodata %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Sensors not recovered

This table lists springs where a sensor previously deployed was not recovered. If there is a visit date associated with the field season, then the spring was visited, but a sensor was not recovered during the visit. If there is no visit date associated with the field season, then the spring was not visited during that field season.

``` {r noretrieval, fig.cap = capTab("Annual spring visits where a sensor was not recovered.")}
nodata <- qcSensorsNotRecovered(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(nodata) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  reactable(dplyr::select(nodata, -Notes),
            defaultColDef = colDef(minWidth = 50),
            searchable = TRUE,
            details = colDef(
              name = "Notes",
              details = function(index) {
                note <- nodata$Notes[index]
                if (!is.na(note)) {
                  return(note)
                }
              }
            ),
            resizable = TRUE,
            compact = TRUE,
            striped = TRUE)
}
```

### Problems with recovered sensors

This table lists the sensors that were recovered with problems. Damaged sensors were recovered in the correct location, but showed obvious damage or tampering. Buried sensors were recovered in the correct location, but found buried under substrate, which could affect their ability to detect surface water presence. Outside water sensors were recovered in the correct location, but found laying outside of nearby surface water. This can happen when sensors are deployed when the spring is dry and the source has to be estimated, or when the source shifts between visits. Wrong location sensors were recovered but not from where they were originally installed. This can happen when flooding during heavy precipitation pulls bolts out of the substrate and washes sensors down stream.

``` {r sensorproblems, fig.cap = capTab("Sensors that were recovered with one or more documented problems.")}
problems <- qcSensorProblems(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(problems) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  reactable(dplyr::select(problems, -Notes),
            defaultColDef = colDef(minWidth = 50),
            searchable = TRUE,
            details = colDef(
              name = "Notes",
              details = function(index) {
                note <- problems$Notes[index]
                if (!is.na(note)) {
                  return(note)
                }
              }
            ),
            resizable = TRUE,
            compact = TRUE,
            striped = TRUE)
}
```

### Sensors both missing and downloaded

This table lists sensors that were successfully downloaded but also recorded as missing. This situation can happen when a sensor is pulled into a rodent burrow or buried by sediment and is not able to be located, but is still near enough to connect via Bluetooth.

``` {r missingsensors, fig.cap = capTab("Sensors that were downloaded but not recovered.")}
missing <- qcMissingSensors(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(missing) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  reactable(dplyr::select(missing, -Notes),
            defaultColDef = colDef(minWidth = 50),
            searchable = TRUE,
            details = colDef(
              name = "Notes",
              details = function(index) {
                note <- missing$Notes[index]
                if (!is.na(note)) {
                  return(note)
                }
              }
            ),
            resizable = TRUE,
            compact = TRUE,
            striped = TRUE)
}
```

### Sensors recovered, download status unknown

This table lists sensors that were recovered, but there is no data if they were successfully downloaded or not.

``` {r sensordownloads, fig.cap = capTab("Sensors that were recovered and have unknown download status.")}
downloads <- qcSensorDownloads(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(downloads) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  reactable(dplyr::select(downloads, -Notes),
            defaultColDef = colDef(minWidth = 50),
            searchable = TRUE,
            details = colDef(
              name = "Notes",
              details = function(index) {
                note <- downloads$Notes[index]
                if (!is.na(note)) {
                  return(note)
                }
              }
            ),
            resizable = TRUE,
            compact = TRUE,
            striped = TRUE)
}
```

### Recovery date same as deployment date

This table lists sensors that have the same recovery and deployment dates. This may indicate an error during data entry.

``` {r sensordates, fig.cap = capTab("Sensors with the same documented recovery and deployment dates.")}
dates <- qcSensorDates(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(dates) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  reactable(dplyr::select(dates, -Notes),
            defaultColDef = colDef(minWidth = 50),
            searchable = TRUE,
            details = colDef(
              name = "Notes",
              details = function(index) {
                note <- dates$Notes[index]
                if (!is.na(note)) {
                  return(note)
                }
              }
            ),
            resizable = TRUE,
            compact = TRUE,
            striped = TRUE)
}
```

### Unknown sensor IDs

This table lists deployed sensors whose sensor ID or serial number are unknown.

``` {r unknownsensorids, fig.cap = capTab("Sensors that were deployed without recording the serial number or sensor ID.")}
unkids <- qcUnknownSensorIDs(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(unkids) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  reactable(dplyr::select(unkids, -Notes),
            defaultColDef = colDef(minWidth = 50),
            searchable = TRUE,
            details = colDef(
              name = "Notes",
              details = function(index) {
                note <- unkids$Notes[index]
                if (!is.na(note)) {
                  return(note)
                }
              }
            ),
            resizable = TRUE,
            compact = TRUE,
            striped = TRUE)
}
```

`r if(params$isAccessible == "yes") {"## Flow condition and water quantity"} else {"## Flow condition and water quantity {.tabset}"}`

Water quantity is the master variable in spring environments. The amount, timing, and duration of discharge control the character and extent of different aquatic habitats, the abundance of wetland plants that can be supported, and the ability of wildlife to access water for drinking.

### Spring discharge summary

This table provides spring flow condition and either estimated or volumetric discharge for each visit.

``` {r springdischarge, fig.cap = capTab("Spring flow condition, springbrook length, and discharge.")}
springdischarge <- SpringDischarge(conn, data.source = "database")

springdischarge %<>%
  dplyr::rename(DischargeNotes = Notes) %>%
  tidyr::unite("Notes", c("DischargeNotes", "SpringbrookNotes"), remove = TRUE, na.rm = TRUE, sep = " ") %>%
  dplyr::mutate(Notes = case_when(Notes == "" ~ NA_character_,
                                  TRUE ~ Notes))

if (params$isAccessible == "yes") {
  knitr::kable(springdischarge) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  reactable(dplyr::select(springdischarge, -Notes),
            defaultColDef = colDef(minWidth = 150),
            searchable = TRUE,
            details = colDef(
              name = "Notes",
              details = function(index) {
                note <- springdischarge$Notes[index]
                if (!is.na(note)) {
                  return(note)
                }
              }
            ),
            resizable = TRUE,
            wrap = FALSE,
            compact = TRUE,
            striped = TRUE)
}
```

### Spring dry, discharge or springbrook > 0

This table lists visits where the spring was recorded as dry, but either discharge or springbrook length were recorded as greater than 0.

``` {r drynonzero, fig.cap = capTab("Dry springs with recorded discharge or springbrook length.")}
drynonzero <- qcSpringDryWater(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(drynonzero) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  reactable(dplyr::select(drynonzero, -Notes),
            defaultColDef = colDef(minWidth = 50),
            searchable = TRUE,
            details = colDef(
              name = "Notes",
              details = function(index) {
                note <- drynonzero$Notes[index]
                if (!is.na(note)) {
                  return(note)
                }
              }
            ),
            resizable = TRUE,
            compact = TRUE,
            striped = TRUE)
}
```

### Spring not dry, discharge or springbrook = 0

This table lists visits where the spring was not recorded as dry and discharge was recorded as 0 or where the spring was not recorded as dry or wet soil only and springbrook length was recorded as 0. The former situation can arise when wet soil is believed to result from recent rainfall or snowmelt as opposed to groundwater discharge. The latter condition can arise when there is water dripping from a pipe that is not enough to saturate the soil below.

``` {r notdrynowater, fig.cap = capTab("Non-dry springs without recorded discharge or springbrook length.")}
notdrynowater <- qcSpringNotDryNoWater(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(notdrynowater) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  reactable(dplyr::select(notdrynowater, -Notes),
            defaultColDef = colDef(minWidth = 150),
            searchable = TRUE,
            details = colDef(
              name = "Notes",
              details = function(index) {
                note <- notdrynowater$Notes[index]
                if (!is.na(note)) {
                  return(note)
                }
              }
            ),
            resizable = TRUE,
            wrap = FALSE,
            compact = TRUE,
            striped = TRUE)
}
```

### Discharge missing

This table lists visits where estimated or volumetric discharge were not recorded.

``` {r dischargemissing, fig.cap = capTab("Spring visits with missing discharge data.")}
dischargemissing <- qcDischargeMissing(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(dischargemissing) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  reactable(dplyr::select(dischargemissing, -Notes),
            defaultColDef = colDef(minWidth = 50),
            searchable = TRUE,
            details = colDef(
              name = "Notes",
              details = function(index) {
                note <- dischargemissing$Notes[index]
                if (!is.na(note)) {
                  return(note)
                }
              }
            ),
            resizable = TRUE,
            compact = TRUE,
            striped = TRUE)
}
```

### Volumetric method data missing

This table lists visits where the volumetric method was used, but container volume, percent of flow, or fill time data were not recorded. Missing any one of these data types makes it impossible to calculate discharge.

``` {r volumetricmissing, fig.cap = capTab("Volumetric discharge measurements with missing volumetric data.")}
volumetricmissing <- qcVolumetricMissing(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(volumetricmissing) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  volumetricmissing %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Volumetric method fills < 5

This table lists visits where the volumetric method was used, but there are fewer than 5 fill times. Typically, at least 5 fill times are necessary to reduce the effect of outliers on determining the median fill time.

``` {r fillevents, fig.cap = capTab("Volumetric discharge measurements with fewer than five fill times.")}
fillevents <- qcVolumetricFillEvents(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(fillevents) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  fillevents %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Volumetric method median fill seconds < 5

This table lists visits where the volumetric method was used, but the median fill time was less than 5 seconds. Typically, fill times should be greater than 5 seconds to provide sufficient accuracy and precision.

``` {r filltimes, fig.cap = capTab("Volumetric discharge measurements with median fill time less than five seconds.")}
filltimes <- qcVolumetricTimes(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(filltimes) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  filltimes %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Continuous > discontinuous

This table lists visits where continuous surface water length is greater than discontinuous surface water length. This results from error during data entry.

``` {r continuouslength, fig.cap = capTab("Continuous surface water length greater than discontinuous surface water length.")}
continuouslength <- qcContinuousLength(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(continuouslength) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  continuouslength %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Continuous flow category summary

This table summaries flow categories for the continuous portion of springbrooks.

``` {r flowcatcon, fig.cap = capTab("Flow category summaries for the continuous portion of springbrooks at each park.")}
flowcatcon <- FlowCategoriesContinuous(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(flowcatcon) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  flowcatcon %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Discontinuous flow category summary

This table summaries flow categories for the discontinuous portion of springbrooks, where springbrook lengths are discontinuous, and the continuous portion of springbrooks, where springbrook lengths are continuous.

``` {r flowcatdiscon, fig.cap = capTab("Flow category summaries for the discontinuous portion of springbrooks at each park.")}
flowcatdiscon <- FlowCategoriesDiscontinuous(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(flowcatdiscon) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  flowcatdiscon %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Flow categories annual plot

This stacked bar plot summarizes flow categories for annual springs, using the discontinuous portion of springbrooks where applicable.

``` {r flowcatannualplot, fig.cap = capFig("Stacked bar plot of flow categories at annual springs for each park.")}
flowcatannualplot <- FlowCategoriesAnnualPlot(conn, data.source = "database")

if (params$isAccessible == "yes") {
  flowcatannualplot
} else {
  ggplotly(flowcatannualplot) %>%
    layout(
      legend = list(
        orientation = "h",
        y = -0.2,
        title = list(text = "Flow Category")
      )
    )
}
```

### Flow categories three-year plot

This stacked bar plot summarizes flow categories for 3-year springs, using the discontinuous portion of springbrooks where applicable.

``` {r flowcat3yrplot, fig.cap = capFig("Stacked bar plot of flow categories at 3-yr springs for each park.")}
flowcat3yrplot <- FlowCategoriesThreeYearPlot(conn, data.source = "database")

if (params$isAccessible == "yes") {
  flowcat3yrplot
} else {
  ggplotly(flowcat3yrplot) %>%
    layout(
      legend = list(
        orientation = "h",
        y = -0.2,
        title = list(text = "Flow Category")
      )
    )
}
```

### Flow categories annual heatmap

This heatmap shows flow categories at each annual spring over all field seasons, using the discontinuous portion of springbrooks where applicable.

``` {r flowcatannualheatmap.1, out.height = 600, fig.cap = capFig("Heatmap of flow categories at annual springs in DEVA."), warning = FALSE}
flowcatannualheatmap <- FlowCategoriesAnnualHeatMap(conn, park = "DEVA", data.source = "database")

if (params$isAccessible == "yes") {
  flowcatannualheatmap
} else {
  ggplotly(flowcatannualheatmap, tooltip = "text")
}
```

``` {r flowcatannualheatmap.2, out.height = 350, fig.cap = capFig("Heatmap of flow categories at annual springs in JOTR."), warning = FALSE}
flowcatannualheatmap <- FlowCategoriesAnnualHeatMap(conn, park = "JOTR", data.source = "database")

if (params$isAccessible == "yes") {
  flowcatannualheatmap
} else {
  ggplotly(flowcatannualheatmap, tooltip = "text")
}
```

``` {r flowcatannualheatmap.3, out.height = 350, fig.cap = capFig("Heatmap of flow categories at annual springs in LAKE.")}
flowcatannualheatmap <- FlowCategoriesAnnualHeatMap(conn, park = "LAKE", data.source = "database")

if (params$isAccessible == "yes") {
  flowcatannualheatmap
} else {
  ggplotly(flowcatannualheatmap, tooltip = "text")
}
```

``` {r flowcatannualheatmap.4, out.height = 350, fig.cap = capFig("Heatmap of flow categories at annual springs in MOJA.")}
flowcatannualheatmap <- FlowCategoriesAnnualHeatMap(conn, park = "MOJA", data.source = "database")

if (params$isAccessible == "yes") {
  flowcatannualheatmap
} else {
  ggplotly(flowcatannualheatmap, tooltip = "text")
}
```

``` {r flowcatannualheatmap.5, out.height = 350, fig.cap = capFig("Heatmap of flow categories at annual springs in PARA.")}
flowcatannualheatmap <- FlowCategoriesAnnualHeatMap(conn, park = "PARA", data.source = "database")

if (params$isAccessible == "yes") {
  flowcatannualheatmap
} else {
  ggplotly(flowcatannualheatmap, tooltip = "text")
}
```

### Flow categories three-year heatmap

This heatmap shows flow categories at each three year spring over all field seasons, using the discontinuous portion of springbrooks where applicable.

``` {r flowcat3yrheatmap.1, out.height = 1450, fig.cap = capFig("Heatmap of flow categories at 3-yr springs in DEVA.")}
flowcat3yrheatmap <- FlowCategoriesThreeYearHeatMap(conn, park = "DEVA", data.source = "database")

if (params$isAccessible == "yes") {
  flowcat3yrheatmap
} else {
  ggplotly(flowcat3yrheatmap, tooltip = "text")
}
```

``` {r flowcat3yrheatmap.2, out.height = 650, fig.cap = capFig("Heatmap of flow categories at 3-yr springs in DEVA.")}
flowcat3yrheatmap <- FlowCategoriesThreeYearHeatMap(conn, park = "JOTR", data.source = "database")

if (params$isAccessible == "yes") {
  flowcat3yrheatmap
} else {
  ggplotly(flowcat3yrheatmap, tooltip = "text")
}
```

``` {r flowcat3yrheatmap.3, out.height = 800, fig.cap = capFig("Heatmap of flow categories at 3-yr springs in LAKE.")}
flowcat3yrheatmap <- FlowCategoriesThreeYearHeatMap(conn, park = "LAKE", data.source = "database")

if (params$isAccessible == "yes") {
  flowcat3yrheatmap
} else {
  ggplotly(flowcat3yrheatmap, tooltip = "text")
}
```

``` {r flowcat3yrheatmap.4, out.height = 800, fig.cap = capFig("Heatmap of flow categories at 3-yr springs in MOJA.")}
flowcat3yrheatmap <- FlowCategoriesThreeYearHeatMap(conn, park = "MOJA", data.source = "database")

if (params$isAccessible == "yes") {
  flowcat3yrheatmap
} else {
  ggplotly(flowcat3yrheatmap, tooltip = "text")
}
```

``` {r flowcat3yrheatmap.5, out.height = 800, fig.cap = capFig("Heatmap of flow categories at 3-yr springs in PARA.")}
flowcat3yrheatmap <- FlowCategoriesThreeYearHeatMap(conn, park = "PARA", data.source = "database")

if (params$isAccessible == "yes") {
  flowcat3yrheatmap
} else {
  ggplotly(flowcat3yrheatmap, tooltip = "text")
}
```

### Flow category map

This map shows flow categories at annual and three year springs, using the discontinuous portion of springbrooks where applicable. If there is a field season slider at the top of the map, then data from a specific field season may be selected. If there is no field season slider, then data from the most recent field season are shown.

``` {r flowcatmap, echo = FALSE, message = FALSE, warning = FALSE, fig.cap = capFig("Map of spring flow categories in each park.")}
if (params$isAccessible == "yes") {
  flowcatmap_access <- FlowCategoriesMap(conn, interactive = "no", data.source = "database")
  flowcatmap_access
} else {
  flowcatmap_interactive <- FlowCategoriesMap(conn, interactive = "yes", data.source = "database")
  flowcatmap_interactive
}
```

`r if(params$isAccessible == "yes") {"## Water quality"} else {"## Water quality {.tabset}"}`

Water quality includes four parameters: water temperature, specific conductance, pH, and dissolved oxygen. Water temperature influences many chemical and physical properties of water as well as the metabolic activity of aquatic organisms. Specific conductance is related to salinity and measures the concentration of dissolved ions in the water, which can help detect contamination or disturbance. pH affects the solubility and toxicity of chemicals and heavy metals in the water. Dissolved oxygen sustains aquatic organisms that breathe aerobically, including crustaceans, mollusks, insects, amphibians, and fish.

### Water quality sanity

These are water quality values that fall above or below the ranges that we typically see in spring systems. These data are not necessarily incorrect, but they are outliers that should be evaluated using data quality flags and field notes. Wildly impossible values may be the result of instrument malfunction, improper calibration, or typos during data entry. The following records are included in the list below: temperature values greater than 30 C, pH values greater than 10 and less than 6, specific conductance values greater than 20000 uS/cm, dissolved oxygen percent values greater than 110% or less than 2%, and dissolved oxygen concentration values greater than 12 mg/L.

``` {r wqsanity}
wqsanity <- qcWqSanity(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(wqsanity) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  wqsanity %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Water quality flags

These are water quality values that have data quality flags. I = Information: These data do not have any suspected problems, but there may be information regarding the equipment or conditions in which they were collected that could inform their interpretation. W = Warning: These data are suspected to have problems and should only be used after careful assessment of instrument and environmental factors. C = Critical: These data are suspected to have serious problems and are likely unusable.

``` {r wqflags}
wqflags <- qcWqFlags(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(wqflags) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  reactable(dplyr::select(wqflags, -FlagNote),
            defaultColDef = colDef(minWidth = 50),
            searchable = TRUE,
            details = colDef(
              name = "Notes",
              details = function(index) {
                note <- wqflags$FlagNote[index]
                if (!is.na(note)) {
                  return(note)
                }
              }
            ),
            resizable = TRUE,
            compact = TRUE,
            striped = TRUE)
}
```

### Local dissolved oxygen calibration

This table lists visits where dissolved oxygen percent was not calibrated to local dissolved oxygen. When calibrating to local dissolved oxygen, the calibration value is 100% regardless of the barometric pressure at the time of calibration. The 100% calibration value for this convention reflects the fact that the calibration environment is at 100% oxygen pressure for that specific location.

``` {r docalcheck}
localdo <- qcLocalDOCheck(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(localdo) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  localdo %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Specific conductance standards

This table lists visits where the specific conductance standard used during calibration was much lower than the in-situ reading of specific conductance at the spring. Ideally, specific conductance standards of 10,000 uS/cm or even 50,000 uS/cm should be used at springs with consistently higher specific conductance readings.

``` {r spcondstandardcheck}
scstandard <- qcSpCondStandardCheck(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(scstandard) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  scstandard %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Water quality summary statistics

This table summarizes the median and quartile values for each water quality parameter for each park and field season. Data flagged as “Warning” or “Critical” are not included.

``` {r wqstats}
wqstats <- WqStats(conn, data.source = "database")

wqstats %<>% dplyr::filter(Park != "CAMO")

if (params$isAccessible == "yes") {
  knitr::kable(wqstats) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  wqstats %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Water temperature box plot

These box plots show the median and quartile values for water temperature (C) for each park and year. Data flagged as “Warning” or “Critical” are not included.

``` {r tempplot, message = FALSE}
tempplot <- WqPlotTemp(conn, data.source = "database")

if (params$isAccessible == "yes") {
    tempplot
} else {
    ggplotly(tempplot)
}
```

### pH box plot

These box plots show the median and quartile values for pH for each park and year. Data flagged as “Warning” or “Critical” are not included.

``` {r phplot, message = FALSE}
phplot <- WqPlotPH(conn, data.source = "database")

if (params$isAccessible == "yes") {
    phplot
} else {
    ggplotly(phplot)
}
```

### Specific conductance box plot

These box plots show the median and quartile values for specific conductance (uS/cm) for each park and year. Data flagged as “Warning” or “Critical” are not included.

``` {r spcondplot, message = FALSE, warning = FALSE}
spcondplot <- WqPlotSpCond(conn, data.source = "database")

if (params$isAccessible == "yes") {
    spcondplot
} else {
    ggplotly(spcondplot)
}
```

### Dissolved oxygen box plot

These box plots show the median and quartile values for dissolved oxygen concentration (mg/L) for each park and year. Data flagged as “Warning” or “Critical” are not included.

``` {r doplot, message = FALSE}
tempplot <- WqPlotDOmgL(conn, data.source = "database")

if (params$isAccessible == "yes") {
    tempplot
} else {
    ggplotly(tempplot)
}
```

### Temperature map

This map shows water temperature (C) at annual and three year springs. If there is a field season slider at the top of the map, then data from a specific field season may be selected. If there is no field season slider, then data from the most recent field season are shown.

``` {r tempmap, message = FALSE}
tempmap <- WqMapTemp(conn, data.source = "database")

tempmap
```

### Specific conductance map

This map shows specific conductance (uS/cm) at annual and three year springs. If there is a field season slider at the top of the map, then data from a specific field season may be selected. If there is no field season slider, then data from the most recent field season are shown.

``` {r spcondmap, message = FALSE}
spcondmap <- WqMapSpCond(conn, data.source = "database")

spcondmap
```

### pH map

This map shows pH at annual and three year springs. If there is a field season slider at the top of the map, then data from a specific field season may be selected. If there is no field season slider, then data from the most recent field season are shown.

``` {r phpmap, message = FALSE}
phmap <- WqMapPH(conn, data.source = "database")

phmap
```

### Dissolved oxygen map

This map shows dissolved oxygen concentration (mg/L) at annual and three year springs. If there is a field season slider at the top of the map, then data from a specific field season may be selected. If there is no field season slider, then data from the most recent field season are shown.

``` {r domap, message = FALSE}
domap <- WqMapDO(conn, data.source = "database")

domap
```

`r if(params$isAccessible == "yes") {"## Riparian vegetation"} else {"## Riparian vegetation {.tabset}"}`

### Vegetation present, no lifeforms

This table lists visits where vegetation was recorded as present, but no lifeforms were documented.

``` {r vegnolife}
vegnolife <- qcVegPresentNoLifeforms(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(vegnolife) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  vegnolife %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### No vegetation observed, lifeforms present

This table lists visits where vegetation was not recorded as present, but lifeforms were documented.

``` {r noveglife}
noveglife <- qcNoVegLifeformsPresent(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(noveglife) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  noveglife %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Lifeform present, no rank

This table lists visits where one or more lifeforms are missing a rank.

``` {r lifenorank}
lifenorank <- qcLifeformPresentNoRank(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(lifenorank) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  lifenorank %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Lifeform rank check

This table lists visits where multiple life forms have the same rank, and rank gaps have not been properly entered.

``` {r rankcheck}
rankcheck <- qcLifeformRankCheck(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(rankcheck) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  rankcheck %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Lifeform observations

This table counts the number of springs where each lifeform was observed in each park and field season.

``` {r lifeformobservations}
lifeformobservations <- LifeformsPresence(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(lifeformobservations) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  lifeformobservations %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Lifeforms per spring plot

This bar plot shows the number of different lifeforms that were observed at springs in each park across all field seasons. The black vertical line indicates the median number of different lifeforms at springs in each park across all field seasons, while the red dashed line indicates the mean number of different lifeforms at springs in each park across all field seasons.

``` {r lifeformsperspringplot, fig.height = 8, warning = FALSE}
lifeformsperspringplot <- LifeformsPerSpringPlot(conn, data.source = "database")

if (params$isAccessible == "yes") {
  lifeformsperspringplot
} else {
  p <- ggplotly(lifeformsperspringplot, tooltip = c("text"))
  
  # Get the names of the legend entries
  df <- data.frame(id = seq_along(p$x$data), legend_entries = unlist(lapply(p$x$data, `[[`, "name")))
  # Extract the group identifier
  df$legend_group <- gsub("^\\((.*?),\\d+\\)", "\\1", df$legend_entries)
  # Add an indicator for the first entry per group
  df$is_first <- !duplicated(df$legend_group)
  
  for (i in df$id) {
  # Is the layer the first entry of the group?
  is_first <- df$is_first[[i]]
  # Assign the group identifier to the name and legendgroup arguments
  p$x$data[[i]]$name <- df$legend_group[[i]]
  p$x$data[[i]]$legendgroup <- p$x$data[[i]]$name
  # Show the legend only for the first layer of the group 
  if (!is_first) p$x$data[[i]]$showlegend <- FALSE
  }
  p
}
```

### Most common lifeforms plot

This bar plot shows the number of observations of each lifeform in each park across all field seasons. Lifeforms are sorted by most common to least common in each park.

``` {r lifeformsobservationsplot, fig.height = 10}
lifeformsobservationsplot <- MostCommonLifeformsPlot(conn, data.source = "database")

if (params$isAccessible == "yes") {
  lifeformsobservationsplot
} else {
  ggplotly(lifeformsobservationsplot, tooltip = "text")
}
```

`r if(params$isAccessible == "yes") {"## Invasive plants"} else {"## Invasive plants {.tabset}"}`

### Targeted invasive plants presence

This table lists visits where targeted invasive plants were observed. Targeted invasive plants include saltcedar (Tamarix ramosissima), California fan palm (Washingtonia filifera), data palm (Phoenix dactylifera), and fountain grass (Pennisetum setaceum). California fans palms are native to Joshua Tree National Park, so any observations there are not included in this table.

``` {r invplants}
invplants <- InvasivePlants(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(invplants) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  reactable(dplyr::select(invplants, -Notes),
            defaultColDef = colDef(minWidth = 50),
            searchable = TRUE,
            details = colDef(
              name = "Notes",
              details = function(index) {
                note <- invplants$Notes[index]
                if (!is.na(note)) {
                  return(note)
                }
              }
            ),
            resizable = TRUE,
            compact = TRUE,
            striped = TRUE)
}
```

### Targeted invasive plants map

This map shows observations of targeted invasive plant species. If there is a field season slider at the top of the map, then data from a specific field season may be selected. If there is no field season slider, then data from the most recent field season are shown.

``` {r invplantmap, echo = FALSE, message = FALSE, warning = FALSE, fig.alt = "Map of targeted invasive plant observations for each field season at each park."}
invplantmap <- InvasivePlantsMap(conn, data.source = "database")

invplantmap
```

`r if(params$isAccessible == "yes") {"## Flow modification and disturbance"} else {"## Flow modification and disturbance {.tabset}"}`

### Overall disturbance < any other disturbance category

This table lists visits where overall disturbance was less than any other disturbance category. This indicates error during data entry.

``` {r overalldisturbance}
overalldisturbance <- qcOverallDisturbance(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(overalldisturbance) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  overalldisturbance %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Flow modification exists, no Human Use disturbance recorded

This table lists visits were flow modification exists, but no human use disturbance was recorded at the spring.

``` {r flowmodnohuman}
flowmodnohuman <- qcFlowModNoHuman(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(flowmodnohuman) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  flowmodnohuman %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Flow modification discrepancies

This table provides a list of springs where different flow modification types have been recorded during different visits. This may happen if a flow modification type is overlooked in one or more field seasons, a spring source shifts, or a different area around the spring source is searched during a visit.

``` {r flowmoddiscrepancies}
flowmoddiscrepancies <- qcFlowModDiscrepancies(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(flowmoddiscrepancies) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  flowmoddiscrepancies %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Springs with active or historic flow modification

This table lists springs where active or inactive (historical) flow modification was observed in each field season.

``` {r flowmodstatus}
flowmodstatus <- FlowModStatus(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(flowmodstatus) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  flowmodstatus %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Flow modification summary

This table lists the number and percentage of springs where active, inactive (historical), or no flow modification have been observed. In situations where there are discrepancies in flow modification observations across different field seasons, the most active disturbance is included.

``` {r flowmodcount}
flowmodcount <- FlowModCount(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(flowmodcount) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  flowmodcount %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Flow modification bar plot

This bar plot shows the percentage of springs in each park where active, inactive (historical), or no flow modification have observed. In situations where there are discrepancies in flow modification observations across different field seasons, the most active disturbance is included.

``` {r flowmodplot}
flowmodplot <- FlowModPlot(conn, data.source = "database")

if (params$isAccessible == "yes") {
  flowmodplot
} else {
  ggplotly(flowmodplot)
}
```

### Disturbance summary

This table lists the number and percentage of springs where human use or livestock disturbance have been observed. In situations where disturbance is not observed in all years, ___________________.

``` {r disturbcount}
disturbcount <- DisturbanceCount(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(disturbcount) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  disturbcount %>%
    reactable(searchable = TRUE, compact = TRUE, striped = TRUE)
}
```

### Human use presence

This table lists visits where human use disturbance was recorded at a spring.

``` {r humanuseobs}
humanuseobs <- HumanUseObservations(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(humanuseobs) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  reactable(dplyr::select(humanuseobs, -Notes),
            defaultColDef = colDef(minWidth = 50),
            searchable = TRUE,
            details = colDef(
              name = "Notes",
              details = function(index) {
                note <- humanuseobs$Notes[index]
                if (!is.na(note)) {
                  return(note)
                }
              }
            ),
            resizable = TRUE,
            compact = TRUE,
            striped = TRUE)
}
```

### Human use plot

This bar plot shows the percentage of springs in each park where human use disturbance was observed.

``` {r humanuseplot}
humanuseplot <- HumanUsePlot(conn, data.source = "database")

if (params$isAccessible == "yes") {
  humanuseplot
} else {
  ggplotly(humanuseplot)
}
```

### Human use map

This map shows where human use disturbance was observed. If there is a field season slider at the top of the map, then data from a specific field season may be selected. If there is no field season slider, then data from the most recent field season are shown.

``` {r humanusemap, echo = FALSE, message = FALSE, warning = FALSE, fig.alt = "Map of human use disturbance observations for each field season at each park."}
humanusemap <- HumanUseMap(conn, data.source = "database")

humanusemap
```

### Livestock presence

This table lists visits where livestock disturbance was recorded at a spring.

``` {r livestockobs}
livestockobs <- LivestockObservations(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(livestockobs) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  reactable(dplyr::select(livestockobs, -Notes),
            defaultColDef = colDef(minWidth = 50),
            searchable = TRUE,
            details = colDef(
              name = "Notes",
              details = function(index) {
                note <- livestockobs$Notes[index]
                if (!is.na(note)) {
                  return(note)
                }
              }
            ),
            resizable = TRUE,
            compact = TRUE,
            striped = TRUE)
}
```

### Livestock plot

This bar plot shows the percentage of springs in each park where livestock disturbance was observed.

``` {r livestockplot}
livestockplot <- LivestockPlot(conn, data.source = "database")

if (params$isAccessible == "yes") {
  livestockplot
} else {
  ggplotly(livestockplot)
}
```

### Livestock evidence map

This map shows where livestock disturbance was observed. If there is a field season slider at the top of the map, then data from a specific field season may be selected. If there is no field season slider, then data from the most recent field season are shown.

``` {r livestockmap, echo = FALSE, message = FALSE, warning = FALSE, fig.alt = "Map of livestock disturbance observations for each field season at each park."}
livestockmap <- LivestockMap(conn, data.source = "database")

livestockmap
```

`r if(params$isAccessible == "yes") {"## Wildlife evidence"} else {"## Wildlife evidence {.tabset}"}`

### Wildlife observed, no types recorded

This table lists visits where wildlife was observed, but no wildlife type was specified.

``` {r wildlifenotype}
wildlifenotype <- qcWildlifeObservedNoTypes(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(wildlifenotype) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  reactable(dplyr::select(wildlifenotype, -Notes),
            defaultColDef = colDef(minWidth = 50),
            searchable = TRUE,
            details = colDef(
              name = "Notes",
              details = function(index) {
                note <- wildlifenotype$Notes[index]
                if (!is.na(note)) {
                  return(note)
                }
              }
            ),
            resizable = TRUE,
            compact = TRUE,
            striped = TRUE)
}
```

### Wildlife type specified, no evidence recorded

This table lists visits where wildlife type was specified, but no evidence type was recorded.

``` {r wildlifenoevidence}
wildlifenoevidence <- qcWildlifeObservedNoEvidence(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(wildlifenoevidence) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  reactable(dplyr::select(wildlifenoevidence, -Notes),
            defaultColDef = colDef(minWidth = 50),
            searchable = TRUE,
            details = colDef(
              name = "Notes",
              details = function(index) {
                note <- wildlifenoevidence$Notes[index]
                if (!is.na(note)) {
                  return(note)
                }
              }
            ),
            resizable = TRUE,
            compact = TRUE,
            striped = TRUE)
}
```

### Ungulates evidence

This table lists visits were evidence of ungulate (sheep or deer) activity was observed at a spring. Evidence can include direct observation, tracks, or scat.

``` {r ungulatesevidence}
ungulatesevidence <- UngulatesEvidence(conn, data.source = "database")

if (params$isAccessible == "yes") {
  knitr::kable(ungulatesevidence) %>%
    kableExtra::kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), full_width = FALSE, position = "left")
} else {
  reactable(dplyr::select(ungulatesevidence, -Notes),
            defaultColDef = colDef(minWidth = 50),
            searchable = TRUE,
            details = colDef(
              name = "Notes",
              details = function(index) {
                note <- ungulatesevidence$Notes[index]
                if (!is.na(note)) {
                  return(note)
                }
              }
            ),
            resizable = TRUE,
            compact = TRUE,
            striped = TRUE)
}
```

### Ungulates evidence map

This map shows where evidence of ungulate (sheep or deer) activity was observed. Evidence can include direction observation, tracks, or scat. If there is a field season slider at the top of the map, then data from a specific field season may be selected. If there is no field season slider, then data from the most recent field season are shown.

``` {r ungulatesmap, echo = FALSE, message = FALSE, warning = FALSE, fig.alt = "Map of targeted invasive plant observations for each field season at each park."}
ungulatesmap <- UngulatesMap(conn, data.source = "database")

ungulatesmap
```

# Usage Notes
A MOJN Desert Springs R Package that is designed to work with the datasets in their published format is available on GitHub. This package was used to implement the quality checks that are included in this report and to generate the three calculated datasets that are included in this data package.

# Acknowledgements
The authors would like to acknowledge Geoff Moret, who developed the Desert Springs protocol.

# References

\pagebreak

# Appendix A. Code Listing
```{r Listing, ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE}
```

\pagebreak

# Appendix B. Session and Version Information
```{r session-info, echo=FALSE, cache=FALSE}
sessionInfo()
Sys.time()
```

``` {r close.db}
# if (params$dataSource == "database") {
#    CloseDatabaseConnection(conn)
# }

CloseDatabaseConnection(conn)
```
